# 테스트

스프링이 개발자에게 제공하는 가장 중요한 가치 → 객체지향과 테스트

테스트는 만들어진 코드를 확신할 수 있게 해주고, 변화에 유연하게 대처할 수 있는 자신감을 줌.

---

### 2.1.1 테스트의 유용성

- 테스트란 **내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인**해서, 만든 코드를 **확신할** 수 있게 해주**는** 작업.
- 또한, 테스트의 결과가 원하는 대로 나오지 않는 경우에는 코드나 설계에 결함이 있음을 알 수 있음.
- 이를 통해 코드의 결함을 제거해가는 작업, 일명 **디버깅**을 거치게 되고, 결국 최종적으로 테스트가 성공하며 **모든 결함이 제거됐다는 확신**을 얻을 수 있음.

---

### 2.1.2 UserDaoTest의 특징

1장에서 만들었던 main() 메소드로 작성된 테스트 코드의 내용

- 자바에서 가장 손쉽게 실행 가능한 main() 이용
- 테스트할 대상인 UserDao의 오브젝트를 가져와 메소드 호출
- **테스트에 사용할 입력 값을 직접 코드에서 만들어 넣어줌**
- 테스트의 결과를 콘솔에 출력
- 각 단계의 작업이 에러 없이 끝나면 콘솔에 성공 메시지로 출력

### 웹을 통한 DAO 테스트 방법의 문제점

<aside>
💡 보통 웹 프로그램에서 사용하는 DAO 테스트 방법

- DAO 만들고 바로 테스트하지 않고 모든 입출력 기능을 대충이라도 코드로 다 만듬.
- 만든 테스트용 웹 어플리케이션을 서버에 배치한 뒤, 웹 화면을 띄워 폼 열고, 값 입력하여 등록
</aside>

위 방법의 문제점 ⇒ DAO뿐만 아니라 서비스 클래스, 컨트롤러, JSP 뷰 등 모든 레이어의 기능을 다 만들고 나서야 테스트가 가능하다는 문제점 발생. 또한, 에러 메시지와 호출 스택 정보만 보고 원인을 알아내기 어려움.

### 작은 단위의 테스트(⇒단위 테스트)

테스트는 가능하면 작은 단위로 쪼개서 집중해야 함.

테스트의 관심이 다르다면 테스트할 대상을 분리하고 집중해서 접근.

왜? ⇒ 단위테스트를 하는 이유는 개발자가 설계하고 만든 코드가 원래 의도한 대로 동작하는지를 개발자 스스로 빨리 확인받기 위해서임.

### 자동수행 테스트 코드

테스트 코드 작성 시 사람의 수작업을 거치는 방법보다는 자동으로 수행될 수 있어야하는 것이 중요.

### 2.1.3 UserDaoTest의 문제점

- 수동 확인 작업의 번거로움
    - 데이터의 준비는 자동으로 진행되지만 add()에서 User 정보를 DB에 등록하고, 다시 get()을 이용해 가져왔을 때 입력값과 가져온 값이 일치하는지는 사람이 확인해야 함.
- 실행 작업의 번거로움
    - DAO가 수백 개가 되고 그에 대한 main()도 추가된다면 전체 기능을 테스트하려면 main()을 매번 실행해야 함.

## 2.2 UserDaoTest 개선

### 2.2.1 테스트 검증의 자동화

첫 번째 문제점 : add()에 전달한 User 오브젝트에 담긴 사용자 정보와 get()을 통해 다시 DB에서 가져온 User 오브젝트의 정보가 서로 일치하는지 확인할 수 있게 하는 것

<aside>
💡 테스트 에러와 테스트 실패

- 테스트 에러 : 테스트가 진행되는 동안 에러가 발생해서 실패하는 경우
- 테스트 실패 : 테스트 작업 중 에러가 발생하진 않았지만 기대한 결과와 다른 경우
</aside>

테스트 실패의 경우에는 별도의 확인 작업이 필요함.

```java
System.out.println(user2.getName());
System.out.println(user2.getPassword());
System.out.println(user2.getId()+ "조회 성공");
//이 코드에서 조회 성공은 조회 테스트가 모두 성공이라는 것이
//아닌 get()메소드가 에러없이 끝났다는 것을 의미
```

```java
if(!user.getName().equals(user2.getName())){
	System.out.println("테스트 실패(name)");
}
else if(!user.getPassword().equals(user2.getPassword())){
	System.out.println("테스트 실패(name)");
}
else{
	System.out.println("조회 테스트 성공");
}
```

### 2.2.2 테스트의 효율적인 수행과 결과 관리

### JUnit 테스트로 전환

JUnit 프레임워크가 요구하는 조건 두가지

1. 메소드는 public으로 선언돼어야 함.
2. 메소드에 @Test라는 어노테이션을 붙여주어야 함.

```java
public class UserDaoTest{
	@Test
	public void addAndGet() throws SQLException{ //main() 대신 일반 메소드로
		ApplicationContext context = new ClassPathXmlApplicationCon
		....
	}
}
```

### 검증 코드 전환

JUnit에서 제공해주는 asserThat이라는 스태틱 메소드를 이용 asserThat(user2.getName().is(user.getName()));

### JUnit 테스트 실행

JUnit은 asserThat을 이용해 검증 시 기대한 결과가 아니면 AssertionError를 던짐.

## 2.3 개발자를 위한 테스팅 프레임워크 JUnit

JUnit은 사실상 자바의 표준 테스팅 프레임워크로 불림

JUnit은 단순하고 빠를 뿐만 아니라 여러 가지 부가기능을 제공함.

### 2.3.2 테스트 결과의 일관성

- deleteAll
    - 해당 테이블의 모든 레코드를 삭제해주는 기능
- getCount()
    - 해당 테이블의 레코드 개수를 돌려줌

deleteAll()이 작동한다면 실행 후에 getCount()의 결과는 0

<aside>
💡 ‘**단위 테스트는 항상 일관성 있는 결과가 보장돼야 한다’** 는 사실을 잊지 말자!

 (외부환경에 영향을 받지 말아야 하고, 테스트 실행 순서를 바꾸어도 동일한 결과를 보장해야 함.)

</aside>

### 2.3.3 포괄적인 테스트

- getCount 테스트하기

시나리오 : USER 테이블의 데이터를 모두 지우고 getCount()로 레코드 개수가 0임을 확인 → 4개의 사용자 정보를 하나씩 추가하여 getCount()의 결과가 증가하는지 확인

```java
@Test
public void count() throws SQLException{
	...
	
	UserDao dao = context.getBean("userDao",UserDao.class);
	User user1 = new User("jimin", "지민", "springno1");
	User user2 = new User("daae", "다애", "springno2");
	User user3 = new User("sumni", "수민", "springno3");
	User user3 = new User("blackbean", "서현", "springno4");

	dao.deleteAll();
	asserThat(dao.getCount(), is (0));

	dao.add(user1);
	asserThat(dao.getCount(), is (1));

	dao.add(user2);
	asserThat(dao.getCount(), is (2));

	dao.add(user3);
	asserThat(dao.getCount(), is (3));

	dao.add(user4);
	asserThat(dao.getCount(), is (4));
}
```

- get() 예외조건에 대한 테스트
    - 모든 User 데이터를 지우고 존재하지 않는 id로 get() 메소드 실행하면 끝!
    - @Test(expected=EmptyResultDataAccessException.class)를 통해 테스트 중 발생할 것으로 기대하는 예외 클래스를 지정
- id에 해당하는 데이터가 없을 때의 테스트
    - EmptyResultDataAccessException 에러 던지기

### 2.3.4 테스트가 이끄는 개발

### 기능설계를 위한 테스트

![Screen Shot 2022-11-29 at 10.40.45 PM.png](%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%2003846d59edbc458bb4f8126b180e9778/Screen_Shot_2022-11-29_at_10.40.45_PM.png)

이 테스트 코드는 기능정의서같이 보임

### 테스트 주도 개발(TDD)

**‘실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다’**는 것이 기본 원칙

TDD는 아예 테스트를 먼저 만들고 그 테스트가 성공하도록 코드만 만드는 식으로 진행하기 때문에 테스트를 빼먹지 않고 꼼꼼하게 만들어낼 수 있음.

### 2.3.5 테스트 코드 개선

### @Before

중복됐던 코드를 넣을 setUp()이라는 이름의 메소드를 만들고 테스트 메소드에서 제거한 코드를 넣음.

<aside>
💡 JUnit 테스트 수행 방식

1. 테스트 클래스ㅔ서 @Test가 붙은 public이고 void형이며 파라미터가 없는 테스트 메소드를 찾는다.
2. 테스트 클래스의 오브젝트를 하나 만든다.
3. @Before가 붙은 메소드가 있으면 실행한다.
4. @Test가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둔다.
5. @After가 붙은 메소드가 있으면 실행한다.
6. 나머지 모든 테스트 메소드에 대해 2~5번 반복
7. 모든 테스트의 결과를 종합해 리턴
</aside>

## 2.4 스프링 테스트 적용

어플리케이션 컨텍스트 생성 방식

@Before 메소드가 테스트 메소드 개수만큼 반복되기 때문에 어플리케이션 컨텍스트도 여러번 반복

```java
@RunWith(SpringJUnit4ClassRunner.class)
//스프링의 테스트 컨텍스트 프레임워크의 JUnit확장기능 지정
@ContextConfiguration(locations="/applicationContext.xml")
//테스트 컨텍스트가 자동으로 만들어줄 애플리케이션 컨텍스트의 위치 지정
public class UserDaoTest{
	@Autowired
	private Applicationcontext context;
	...

	@Before
	public void setUp(){
		this.dao = this.context.getBean("userDao", UserDao.class);
		...
	}
}
```

SpringJUnit4ClassRunner라는 JUnit용 테스트 컨테스트 프레임워크 확장 클래스를 지정해주면 테스트 진행하는 중에 테스트가 사용할 애플리케이션 컨텍스트를 만들고 관리하는 작업을 진행해줌.

### 2.4.2 DI와 테스트

효율적인 테스트를 손쉽게 만들기 위해서라도 DI를 적용해야 함. 

### 테스트에 DI를 이용하는 방법

- 테스트 코드에 의한 DI
    - 테스트 코드 내에서 직접 DI를 해도 됨.
    
    → XML 설정 파일을 수정하지 않고도 테스트 코드를 통해 오브젝트 관계를 재구성할 수 있음.
    
    - 하지만 의존관계를 강제 변경하였기 때문에 한 번 변경 시 나머지 모든 테스트가 수행되는 동안 변경된 애플리케이션 컨텍스트를 사용하게 됨.
    - @DirtiesContext : 스프링의 테스트 컨텍스트 프레임워크에게 해당 클래스의 테스트에서 애플리케이션 컨텍스트의 상태를 변경한다는 것을 알려줌.
- 테스트를 위한 별도의 DI 설정
    - 아예 테스트 전용 설정 파일을 따로 만듬.
- 컨테이너 없는 DI 테스트
    - @Before메소드에 직접 UserDao의 오브젝트를 생성하고 테스트용 DataSourse 오브젝트를 만듬.

## 2.5 학습 테스트로 배우는 스프링

### 학습테스트

자신이 만들지 않는 프레임워크나 다른 팀에서 제공한 라이브러리 등에 대한 테스트

- 기능에 대한 검증이 목적이 아닌
- 테스트를 만들려는 기술이나 기능에 대해 제대로 이해하고 있고 방법을 알고 있는지를 검증하는 목적
- 또, 테스트 코드를 작성해보면서 빠르고 정확하게 사용법을 익히는 목적

### 학습 테스트의 장점

- 다양한 조건에 따른 기능을 손쉽게 확인해볼 수 있음.
- 학습 테스트 코드를 개발 중에 참고할 수 있음.
- 프레임워크나 제품을 업그레이드할 때 호환성 검증을 도와줌.
- 테스트 작성에 대한 좋은 훈련
- 새로운 기술을 공부하는 과정이 즐거워짐

### 버그 테스트

코드에 오류가 있을 때 그 오류를 가자 잘 드러내줄 수 있는 테스트

- 일단 실패하도록 만들어야 함
- 버그 테스트의 필요성과 장점
    - 테스트의 완성도 높임
    - 버그의 내용 명확히 분석
    - 기술적 문제 해결에 도움