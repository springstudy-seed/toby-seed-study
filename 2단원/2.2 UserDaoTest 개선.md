# 2.2 UserDaoTest 개선

그럼 앞선 두 가지 문제점(수동 확인 작업, 실행 작업의 번거로움) 문제점을 해결해보자.

### 2.2.1 테스트 검증의 자동화

---

테스트는 성공과 실패 두 가지 결과를 가질 수 있다.

- 테스트 에러 : 테스트가 진행되는 동안에 에러가 발생해서 실패 → 에러로 확인 가능
- 테스트 실패 : 결과가 기대한 것과 다르게 나오는 경우 → 별도의 확인 작업 필요

새로 도입한 기술에 문제가 없는지 확인할 수 있는 좋은 방법은

빠르게 실행가능하고 스스로 테슽트 수행과 기대하는 결과에 대한 확인을 해주는 자동화된 코드를 만드는 것

### 2.2.2 테스트의 효율적인 수행과 결과 관리

---

JUnit : 테스트 지원 도구

**JUnit 테스트로 전환**

JUnit은 프레임워크이다.

프레임워크의 기존 동작원리는 IoC(제어의 역전)이다.

프레임워크는 개발자가 만든 클래스에 대한 제어의 권한을 넘겨받아 주도적으로 애플리케이션 흐름을 제어한다.

따라서 개발자가 만든 클래스의 오브젝트를 생성하고 실행하는 일은 프레임워크에 의해 실행된다.

→ 프레임워크에서 동작하는 코드는 main()메서드가 필요하지 않다. 또한 오브젝트를 만들어서 실행시키는 코드를 만들 필요도 없다. (의문)

**테스트 메소드 전환**

테스트가 main()메서드로 만들어졌다는 것은 직접 제어권을 가진다는 의미이므로 프레임워크에 적용하기 적합하지 않다

따라서 main() 메서드에 있던 테스트 코드를 일반 메서드로 옮기는 작업이 필요하다.

JUnit 프레임워크가 요구하는 테스트 메서드는

1. 메서드는 public으로 선언, 리턴값은 void형, 파라미터는 존재하지 않는다.
2. 테스트 메서드에 @Test 어노테이션 붙이기

하나의 클래스에 여러 개의 테스트 메서드가 들어갈 수 있다.

**검증 코드 전환**

```java
if(!user.getName().equals(user2.getName())){...}
```

이 if문장을 대신해주는 것은 JUnit의 assertThat이라는 static method이다.

```java
assertThat(user2.getName(),is(user1.getName()))
```

첫 번째 파라미터의 값을 뒤에 나오는 매처라고 불리는 조건으로 비교해서 일치하면 다음으로 넘어가고, 아니면 테스트가 실패한다.

asserThat을 사용하자!

1. assertThat은 다른 assertxxx보다 읽기 쉽다.

```java
assertEquals(expected, actual);
```

actual과 expected의 위치를 헷갈린다.

하지만,

```java
assertThat(actual, is(expected));
```

1. Type의 안정성

컴파일에는 성공하지만, 실행시 실패한다.

```java
assertEquals("abc", 123);
```

컴파일 자체가 실패한다.

```java
assertThat(123, is("abc"));
```

**JUnit 테스트 실행**

JUnit 프레임워크를 통해서 테스트 메서드를 실행하는 코드를 작성했다.

JUnit 프레임워크 시작을 어디선가 시켜주어야 한다.

```java
import org.junit.runner.JUnitCore;

public static void main(String[]args){
	JUnitCore.main("springboot.user.dao.UserDaoTest");
}
```

→ main()메서드 안에 JUnitCore 클래스의 main메서드를 호출해주는 코드를 넣으면 된다.

메서드의 파라미터로는 @Test 테스트 메서드를 가진 클래스의 이름을 넣어준다.

JUnit은 assertThat을 통해 검증했을 때 기대한 결과가 아니면  AssertionError을 발생시킨다.

따라서 assertThat() 조건을 맍고시키지 못하면 테스트는 더 이상 진행되지 않는다.