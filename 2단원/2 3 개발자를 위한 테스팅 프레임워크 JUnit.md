# 2.3 개발자를 위한 테스팅 프레임워크 JUnit

> 테스트 없는 스프링은 의미 없다. 
따라서 스프링을 제대로 사용하려면 JUnit 테스트 작성 방법과 실행 방법은 알아야 한다.
> 

### 2.3.1 JUnit 테스트 실행 방법

---

이처럼 JUnitCore을 통해 테스트를 실행하고 콘솔에 출력된 메시지를 보고 결과를 확인할 수도 있다.

```java
import org.junit.runner.JUnitCore;
//...
public static void main(String[] args) {
    JUnitCore.main("spring.user.dao.UserDaoTest");
}
```

**IDE**

`@Test` 가 들어있는 테스트 클래스를 실행시키거나 테스트 메서드를 실행시키면

JUnitCore을 이용할 때처럼 main()메서드를 만들지 않아도 된다.

**빌드 툴**

내용 추가

### 2.3.2 테스트 결과의 일관성

---

> 코드에 변경사항이 없다면 항상 동일한 결과를 내야한다.
> 

이전에는 UserDaoTest 를 실행하기 전에 DB의 User정보를 전부 삭제했어야 한다.

그렇지 않으면, 이전 테스트 떄 등록했던 기본키가 중복되어 에러가 발생한다.

하지만, 테스트가 외부 상태에 따라 성공하기도 하고 실패하기도 하는 것은 좋은 것이 아니다.

코드에 변경사항이 없다면 테스트는 항상 동일한 결과를 내야한다.

이에 대한 해결방안은

테스트를 실행하고나서 테스트를 수행하기 이전 상태로 만들어주는 것이다.

이러면 테스트를 여러 번 반복해서 실행하더라도 항상 동일한 결과를 얻을 수 있다.

**deleteAll()의 getCount() 추가**

일관성 있는 결과를 보장하는 테스트를 위해 추가해야함

- deleteAll() : USER 테이블의 모든 레코드를 삭제해줌
- getCount() : USER 테이블의 레코드 개수를 돌려줌

**동일한 결과를 보장하는 테스트**

단위 테스트는 코드가 바뀌지 않는다면 매번 실행할 때마다 동일한 테스트 결과를 얻어야한다.

이를 위해서 하나의 테스트를 마친 후에 DB 테이블을 지워주는 것도 좋지만, 테스트 하기 전에 테스트 실행에 문제가 되지 않은 상태를 만들어주는 것이 좋다.

> 단위 테스트는 항상 일관성 있는 결과가 보장되어야 한다.
> 

DB에 남아있는 데이터와 같은 외부 환경에 영향을 받지 않아야하고, 테스트를 실행하는 순서를 바꿔도 동일한 결과가 나와야한다.

### 2.3.3 포괄적인 테스트

---

테스트를 안 만드는 것도 위험하지만, 성의없이 테스트를 작성하는 바람에 문제가 있는 코드인테도 테스트가 성공하게 만드는 것도 위험하다.

**테스트 메서드의 주의할 점**

- 테스트 메서드는 한 번에 한 가지 검증 목적에만 충실한 것이 좋다.
- JUnit은 테스트 메서드의 실행 순서를 보장해주지 않는다.
    
    따라서 모든 테스트는 실행 순서에 상관없이 독립적으로 동일한 결과를 낼 수 있어야 한다.
    

**get() 예외조건에 대한 테스트**

get() 메서드에 전달된 id 값에 해당하는 사용자 정보가 없다면 id에 해당하는 정보를 찾을 수 없다고 예외를 던질 수 있다.

→ 이때는 스프링의 EmptyResultDataAccessException 예외를 사용

하지만 테스트 중에 예외가 발생하면 테스트 메서드 실행은 중단되고 테스트는 실패한다.

테스트 진행 중에 특정 예외가 던져지면 성공한 것이고, 예외가 던져지지 않고 정상적으로 작업을 마치면 테스트가 실패했다고 판단해야 한다.

JUnit에서는 예외 조건 테스트를 위한 방법을 제공해준다.

바로 @Test의 expected 엘리먼트를 이용하면 된다.

expected 는 테스트 메서드 실행 중에 발생하리라 기대하는 예외 클래스를 넣어주면 된다.

@Test에 expected 엘리먼트를 추가하면 정상적으로 테스트를 마치면 테스트가 실패하고, 지정한 예외가 발생하면 테스트가 성공한다.

**포괄적인 테스트**

> 항상 네거티브 테스트를 먼저 만들라
> 

테스트를 작성할 때 부정적인 케이스를 먼저 만드는 습관을 가지자.

ex) id가 주어졌을 때 레코드를 정확히 가져오는지 확인하는 테스트 작성도 중요하지만,

존재하지 않은 id값이 주어졌을 때 어떻게 반응할지 먼저 결정하고, 이를 확인할 수 있는 테스트를 작성하면 꼼꼼한 개발이 가능하다.

### 2.3.4 테스트가 이끄는 개발

---

**기능설계를 위한 테스트**

기능설계 = test

추가하고 싶은 기능을 테스트 코드로 표현해서, 코드로 된 설계를 만든 것

|  | 단계 | 내용 | 코드 |
| --- | --- | --- | --- |
| 조건 | 어떤 조건을 가지고 | 가져올 사용자 정보가 존재하지 않을 경우 | dao.deleteAll();
assertThat(dao.getCount,is(0)); |
| 행위 | 무엇을 할 때 | 존재하지 않은 Id로 get()을 실행하면 | get(”unknown_id”); |
| 결과 | 어떤 결과가 나온다 | 특정한 예외가 발생한다. | @Test(expected=EmptyResultDataAccessException.class) |

테스트코드 작성 후 실제 기능을 가진 애플리케이션 코드 작성

→ 테스트 코드를 실행해서 설계한 대로 코드가 동작하는지 검증

**테스트 주도 개발**

만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증해줄 수 있는 테스트코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발이 테스트 주도 개발(TDD)이다.

- 실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다.
- 테스트를 작성하고 이를 성공시키는 코드를 만드는 작업의 주기를 가능한 짧게 가져가도록 권장
- 테스트는 코드를 작성한 후에 가능한 빨리 실행할 수 있어야 한다.
- TDD의 장점은 코드를 만들어 테스트를 실행하는 그 사이의 간격이 매우 짧다는 것이다.

### 2.3.5 테스트 코드 개선

---

 JUnit 프레임워크는 테스트 메서드를 실행할 때 부가적으로 해주는 작업이 있다.

테스트를 실행할 때마다 반복되는 준비 작업을 별도의 메서드에 넣게 해주고, 이를 매번 테트스 메서드를 실행하기 전에 실행시켜준다.

ex) 스프링의 애플리케이션 컨텍스트를 만드는 부분, UserDao를 가져오는 부분

```java
ApplicationContext context = new GenericXmlApplicationnContext("application.xml");
User dao=context.getBean("userDao",UserDao.class);
```

`@Before`

@Test 메서드가 실행되기 전에 먼저 실행되더야 하는 메서드를 정의

```java
import org.junit.before;

public class UserDaoTest{
	private UserDao userDao;

	@Before
	public void setUp(){
		ApplicationContext context = new GenericXmlApplicationnContext("application.xml");
		this.userDao=context.getBean("userDao",UserDao.class);
	}
	
	@Test
```

UserDao를 테스트 메서드에서 접근할 수 있도록 인스턴스 변수로 변경한다.

따라서 setUp()에서 getBean이 돌려주는 UserDao오브젝트를 userDao인스턴스 변수에 저장한다.

이후 각 테스트에서 userDao를 사용할 수 있다.

JUnit 프레임워크가 테스트 메서드를 실행하는 과정

cf) 프레임워크는 스스로 제어권을 가지고 주도적으로 동작하고, 개발자가 만든 코드는 프레임워크에 의해 수동적으로 실행된다.

1. 테스트 클래스에서 @Test가 붙은 public이고 void형이며 파라미터가 없는 테스트 메소드를 모두 찾는다.
2. 테스트 클래스의 오브젝트를 하나 만든다.
3. @Before가 붙은 메소드가 있으면 실행한다.
4. @Test가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둔다.
5. @After가 붙은 메소드가 있으면 실행한다.
6. 나머지 테스트 메소드에 대해 2~5번을 반복한다.
7. 모든 테스트의 결과를 종합해서 돌려준다.

- **JUnit은 @Test가 붙은 메소드를 실행하기 전과 후에 각각 @Before와 @After가 붙은 메소드를 자동으로 실행한다**
- @Before @After 메서드를 테스트 메서드에서 직접 호출하지 않기 때문에 서로 주고 받을 정보나 오브젝트가 있다면 인스턴스 변수를 사용해야 한다.
- 각 테스트 메서드를 실행할 때마다 테스트 클래스의 오브젝트를 새로 생성한다.
    
    → 각 테스트가 서로 영향을 받지 않고 독립적으로 실행됨을 확실히 보장하기 위함
    
    ex) 테스트 클래스가 @Test 테스트 메서드를 2개 가지고 잇다면, JUnit은 테스트가 실행되는 중에 이 클래스의 오브젝트를 2번 생성한다.
    
    ![스크린샷 2022-11-27 오후 11.35.33.png](2%203%20%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A1%E1%84%85%E1%85%B3%E1%86%AF%20%E1%84%8B%E1%85%B1%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B5%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%20JUnit%20023140fb51294288a8298b74e31f8cd3/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-11-27_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_11.35.33.png)
    

**픽스처**

테스트를 수행하는데 필요한 정보나 오브젝트를 픽스터라고 한다.

픽스처는 여러 텍스트에서 반복적으로 사용되기 때문에 @Before 메서드를 이용해 생성하면 편하다.

ex) dao, User 오브젝트가 픽스처이다.

```java
public class UserDaoTest{
	private UserDao userDao;
	private User user1;
	private User user2;
	private User user3;
	
	@Before
	public void setUp(){
		this.user1=new User("gyumee","박상철","springno1");
		...
	}

```

인스턴스 변수를 생성하고 오브젝트 생성은 Before 에서 진행한다.

테스트를 할 떄마다 매번 새로운 오브젝트가 생성되므로 인스턴스 변수에서 바로 초기화해도 상관없다.