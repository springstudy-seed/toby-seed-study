# 토비의 스프링 2장_테스트

Stakeholders: 익명
Type: Technical Spec

# Summary

그동안 프로젝트를 진행하면서 내가 맏은 구현부분에 대한 믿음이 없었다. 내 컴퓨터에서만 작동된 경우도 있었고, 무엇보다 상대의 코드와 합쳤을때 잘 작동할것인지에 대한 불안감이 커서 항상 내 코드에 대한 자신이 없었다. 이 때문에 에러에 대한 불안감으로 일주일을 보내다 이 직업이 이렇게 불안한 직업인가에 대한 생각도 했었는데 테스트에 대한 내용을 읽어보니 의존성이 높은 코드, 개발자의 입력에 의존한 테스트가 가장 큰 문제였던것 같다! 개발의 체계성에 감탄한 챕터였다.

# 테스트 = 개발자의 편안함

> 만든 코드는 어떤 방법으로든 테스트 해야한다. 테스트란 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인 해서 코드를 확신할 수 있게 해주는 작업이다.
>
- 테스트는 자동화돼야 하고, 빠르게 실행할 수 있어야 한다.
- Junit 프레임워크를 이용해 테스트를 작성한다.
- 테스트 결과는 일관성있어야한다. 환경이나 테스트 실행 순서에 따라 결과가 달라지면 안된다.
- 충분히 검증을 하지 않는 테스트는 없는 것보다 나쁘다.

### 웹을 통한 DAO 테스트 방법의 문제점

→ 첫 웹프로젝트를 진행하며 밤샘을 했던 시기가 마지막 점검 시기였다. 책에서 말한 모든 문제점이 모두 뼈저리게 공감이 됐다.

- 모든 레이어를 만든 뒤에야 테스트를 할 수 있다.
- 오류가 있을때 빠르고 정확하게 대응하기가 힘들다.
- 테스트의 대상이 너무나 넓어 체계적인 테스트가 힘들다.

### 효율적인 테스트 - 1. 작은 단위의 테스트

테스트하고자하는 대상을 명확히 지정하고, 그 대상에만 집중해서 테스트하는 것이 바람직 하다.

- 작은 단위 코드에 대해 테스트를 수행한 것을 **단위테스트**라고 한다.
- 여기서 **단위**는 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위의 단위이다.
- 상태가 변할 수 있는 DB와 같이 통제할 수 없는 외부의 리소스에 의존하는 테스트는 단위 테스트가 아니라고 보기도 한다.

### 효율적인 테스트 - 2. 자동수행 테스트 코드

- 별도로 테스트용 클래스를 만드러서 테스트 코드를 넣는 편이 낫다.
- 수동이 아닌 자동으로 수행되고, 개발자의 추가 작업없이 코드만으로 대상의 테스트 결과를 판단 할 수 있어야 한다. ex) 값이 같은가, 이 리소스를 사용해 값을 가져오는가?

### 효율적인 수행과 결과 관리 - JUnit

- main() 메소드를 더이상 쓰지 않아도 되고, 개발자가 만든 클래스의 오브젝트 생성, 실행을 junit에 맡길 수 있다.
- junit을 사용하기 위해 1. 메소드가 public으로 선언돼야하고, 2. 메소드에 @Test 애노테이션을 붙여주어야 한다.
- ex)assertThat(user.getName(), is(user.getName())); 와 같이 테스트 코드를 작성 할 수 있다.
- Junit 또한 한번은 프레임워크를 시작해줘야 한다. → main()메소드에 JnuitCore 클래스의 main메소드를 호출해 주면 된다.

![Untitled](%E1%84%90%E1%85%A9%E1%84%87%E1%85%B5%E1%84%8B%E1%85%B4%20%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%202%E1%84%8C%E1%85%A1%E1%86%BC_%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20d046133afc4d43dab310d51123779560/Untitled.png)

- 테스트르 하다보면 DB의 값을 테스트마다 지우고, 초기화해야하는 경우가 발생할 수 있는데 이와 같은 상황은 테스트결과의 일관성에 영향을 줄 수 있다.
- 이때 deleteAll()과 getCount()를 이용해서 DB의 상태를 테스트마다 보장해 줄 수 있다.

→ 책 166p를 읽으면서 deleteAll()을 테스트 마지막에 넣고 싶다는 생각을 했었다. 하지만 혼자 테스트하는 경우 테스트 전의 DB상황을 체크하면되지만, 팀이 함께 일할경우, “테스트”에만 집중할 수 있도록 DB의 상태를 보장해주는 것이 낫다.

여기까지, 토비에서는 addandget()을 통해 user객체가 의도대로 DB입력되는 것을 테스트하고, count()를 통해 DB의 count가 잘 작동하는지 확인했다. 마지막으로 getUserFailuare()를 통해 get()에 예외값이 들어가는 경우 처리에 대해 테스트 했다.

# TDD_테스트 주도 개발

테스트를 먼저 만들고 테스트를 성공시키는 코드를 만들어가는 개발 방법이다.

- 테스트하기 좋은 코드가 좋은 코드이다.
- 테스트를 먼저 만들고 테스트를 성공시키는 코드를 만들어가는 개발 방법이다.
- 테스트 코드도 적절한 리팩토링이 필요하다.

### 기능설계를 위한 테스트

TDD를 사용하면 테스트를 빼먹지 않고 꼼꼼하게 만들어낼 수 있으며, 테스트코드와 애플리케이션 구현 코드 작성하는 시간의 간격이 짧아진다. 무엇보다 가벼운 마음으로 다음 단계로 넘어갈 수 있다.

- 머릿속에서 복잡하게 진행하던 작업을 끄집어내면 TDD가 된다.
- 엔터프라이즈 애플레케이션의 테스트를 만들기가 매우 어렵다고 생각하기 때문에 테스트를 잘 만들지 않는데, 스프링은 테스트하기 편리한 구조의 애플리케이션을 만들게 도와줄 뿐만 아니라 테스트에 대해 편리한 기능을 제공한다. → **테스트 코드를 작성할 수 있는 구조의 애플리케이션을 구현해야한다.**

# @ Before , @ After

before, after 애노테이션은 test 애노테이션 전, 후에 메소드를 자동으로 실행한다.

- 테스트 코드도 적절한 리팩토링이 필요하다.
- @ Before, @ After 를 사용해서 메소드들의 공통 준비 작업과 정리 작업을 처리 할 수 있다.
- Junit은 테스트 메소드를 실행할 때마다 테스트 클래스의 오브젝트를 새로 만든다. → 독립성 보장

![Untitled](%E1%84%90%E1%85%A9%E1%84%87%E1%85%B5%E1%84%8B%E1%85%B4%20%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%202%E1%84%8C%E1%85%A1%E1%86%BC_%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20d046133afc4d43dab310d51123779560/Untitled%201.png)

![Untitled](%E1%84%90%E1%85%A9%E1%84%87%E1%85%B5%E1%84%8B%E1%85%B4%20%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%202%E1%84%8C%E1%85%A1%E1%86%BC_%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20d046133afc4d43dab310d51123779560/Untitled%202.png)

### 픽스처_fixture

테스트를 수행하는 데 필요한 정보나 오브젝트를 픽스처라고 한다.

- add() 메소드에 전달하는 User오브젝트들, UserDaoTest에서 dao

### 테스트를 위한 애플리케이션 컨텍스트 관리

@Before메소드가 테스트 메소드 만큼 반복하기 때문에 앞의 코드에서 애플리케이션 컨텍스트도 세번 만들어진다. → 자원 낭비 → 스프링이 제공하는 애플리케이션 컨텍스트 테스트 지원기능 사용

- 스프링 테스트 컨텍스트 프레임워크 적용하기

![Untitled](%E1%84%90%E1%85%A9%E1%84%87%E1%85%B5%E1%84%8B%E1%85%B4%20%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%202%E1%84%8C%E1%85%A1%E1%86%BC_%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20d046133afc4d43dab310d51123779560/Untitled%203.png)

- 메소드안의 로컬변수 → 인스턴스 변수로 선언, @Autowired 붙여준다.
- @Runwith : JUnit이 테스트를 진행하는 중에 테스트가 사용할 애플리케이션 컨텍스트를 만들고 관리하는 작업을 진행해준다.
- @ContextConfiguration: 자동으로 만들어줄 애플리케이션 컨텍스트의 설정파일 위치를 지정해준다.

# 테스트의 DI 활용

- @ Autowired 를 사용하면 컨텍스트의 빈을 테스트 오브젝트에 DI 할 수 있다.
- 스프링 컨테이너 없이 테스트 할 수 있는 방법
- 스프링 설정파일을 이용한 DI 방식의 테스트
- 의존 관계를 강제로 구성해야하는 테스트 → 컨텍스트에서 DI받은 오브젝트에 다시 테스트 코드로 수동 DI 해서 테스트 하는 방법. (@DirtiesContext 사용)

## 학습테스트

자신이 만들지 않은 프레임워크나 라이브러리등에 대해 사용방법을 익히기 위해 테스트를 작성하는것. 사용방법을 바로 알고있는지 검증하려는것이 목적이다.

- 기술의 사용 방법을 익히고 이해를 돕기 위해 학습 테스트를 작성
- 스프링 또한 배포판의 압축에 테스트코드가 존재한다. → 학습가능!

### 버그테스트

- 오류가 발견될 경우 그에 대한 버그 테스트를 만들어두면 유용하다.
- 버그에 대한 테스트를 작성하면서 놓친 예외, 또는 기능의 결함을 보완할 수 있다.
- 버그의 내용을 명확히 분석하여 오류를 발생시키는 값의 범위(경계값 범위)를 분석 할 수 있다.