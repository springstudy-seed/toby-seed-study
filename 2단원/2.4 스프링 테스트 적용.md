# 2.4 스프링 테스트 적용

@Before 메서드는 테스트 메서드가 실행되기 전에 반드시 실행되므로 메서드 개수만큼 반복된다. 

따라서 애플리케이션 컨텍스트가 여러 개 생성된다.

테스트는 매번 새로운 오브젝트를 만들어서 사용하는 것이 원칙이지만, 애플리케이션 컨텍스트처럼 생성에 많은 시간과 자원이 소모되는 경우 테스트 전체가 공유하는 오브젝트를 생성한다.

→ 이때도, 일관성 있는 실행결과를 보장/테스트 실행순서가 결과에 영향을 미치지 않아야 한다.

하지만 2.3장에서 언급했듯이 테스트 메서드를 실행할 떄마다 테스트 클래스의 오브젝트를 새로 생성한다.

![스크린샷 2022-11-28 오후 1.05.15.png](2%204%20%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%AD%E1%86%BC%208c39111c8e994d1eb04cf462d042c6a6/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-11-28_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_1.05.15.png)

따라서 애플리케이션 컨텍스트를 오브젝트에 저장해도 테스트 클래스에 전체에서 공유되지 않는다.

이에 대한 해결방법은 스태틱 필드에 애플리케이션 컨텍스트를 저장해주면 된다.

JUnit은 태스트 클래스 전체에 걸쳐 단 한번만 실행되는 `@BeforeClass` 스태틱 메서드를 지원한다.

따라서 @BeforeClass 스태틱 메서드에 애플리케이션 컨텍스트를 만들어 스태틱 변수에 저장해두고 테스트 클래스 전체에서 사용하면 된다.

### 2.4.1 테스트를 위한 애플리케이션 컨텍스트 관리

---

JUnit은 테스트 컨텍스트 프레임워크를 지원한다.

- 테스트 컨텍스트 프레임워크
    
    애노테이션 설정만으로 테스트에서 필요로 하는 애플리케이션 컨텍스트를 만들어서 모든 테스트가 공유할 수 있다.
    

**스프링 테스트 컨텍스트 프레임워크 적용**

@Before 메서드에서 애플리케이션 컨텍스트를 테스트 메서드 실행하기 전마다 생성을 했다면

```java
import org.junit.before;

public class UserDaoTest{
	private UserDao userDao;

	@Before
	public void setUp(){
		ApplicationContext context = new GenericXmlApplicationnContext("application.xml");
		this.userDao=context.getBean("userDao",UserDao.class);
	}
...
}
```

ApplicationContext 타입의 인스턴스 변수를 선언하고 @Autowired 애노테이션을 붙인다.

```java
@Runwith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations="/applicationContext.xml")
public class UserDaoTest{
	@Autowired
	private ApplicationContext context;
	
	@Before
	public void setUp(){
		this.dao=this.context.getBean("userDao",UserDao.class);
	}
...
}
```

하지만, context 변수를 초기화해주는 코드가 없는데 NullPointerException이 발생하지 않고  정상적으로 작동한다.

`@RunWith` 에 SpringJUnit4ClassRunner 의 JUnit용 테스트 컨텍스트 프레임웜크를 지정해주면 JUnit이 테스트를 진행하는 중에 테스트가 사용할 애플리케이션을 관리해준다.

`@Configuration` 애플리케이션 컨텍스트의 설정파일 위치 지정

**테스트 메서드의 컨텍스트 공유**

```java
@Before
public void setUp(){
	System.out.println(this.context);
	System.out.println(this);
}
```

![스크린샷 2022-11-28 오후 1.25.24.png](2%204%20%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%AD%E1%86%BC%208c39111c8e994d1eb04cf462d042c6a6/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-11-28_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_1.25.24.png)

JUnit은 테스트 메서드를 실행할 때마다 새로운 테스트 오브젝트를 생성한다.

그런데, context 변수에 어떻게 동일한 애플리케이션 컨텍스트가 들어가있을까?

바로 스프링의 JUnit은 테스트가 실행되기전에 애플리케이션 컨텍스트를 만들어두고, 테스트 오브젝트가 실행될 때마다 Di를 이용해 테스트 오브젝트의 특정 필드에 주입해준다.

따라서 애플리케이션 컨텍스를 재사용할 수 있기에 하나의 테스트 클래스 내의 테스트 메서드들은 같은 애플리케이션 컨텍스트를 공유해서 사용한다.

**테스트 클래스의 컨텍스트 공유**

스프링 테스트 컨텍스트 프레임워크는

하나의 테스트 클래스 내에서 애플리케이션 컨텍스트를 공유하는 것 뿐만 아니라

여러 개의 테스트 클래스가 같은 설정파일을 가진 애플리케이션 컨텍스트를 사용하다면, 테스트 클래스 사이에서도 애플리케이션 컨텍스트가 공유가능하다.

따라서 같은 설정파일을 가진 애플리케이션 컨텍스트의 경우

테스트 클래스가 하나의 애플리케이션 컨텍스트를 공유한다.

![스크린샷 2022-11-28 오후 1.49.16.png](2%204%20%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%AD%E1%86%BC%208c39111c8e994d1eb04cf462d042c6a6/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-11-28_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_1.49.16.png)

다음처럼 테스트 클래스가 같은 설정파일을 사용한다면 테스트 클래스가 애플리케이션 컨텍스트

트를 공유할 수 있다.

**@Autowired**

`@Autowired` 가 붙은 인스턴스 변수가 있으면, 테스트 컨텍스트 프레임워크는 변수 타입과 일치하는 컨텍스트 내의 빈을 찾아 주입해준다.

하지만, 이상한 점은 ApplicationContext은 applicationContext.xml에 정의된 빈이 아닌데, ApplicationContext가 DI 된 이유는 뭘까?

```java
	@Autowired
	private ApplicationContext context;
```

바로, 스프링 애플리케이션 컨텍스트는 초기화할 때 자기 자신도 빈으로 등록한다.

따라서 애플리케이션 컨텍스트에는 ApplicationContext 타입의 빈이 존재하고 DI가 가능해진다.

```java
@Autowired
UserDao userDao;
```

@Autowired는 변수에 할당한 타입을 가진 빈을 자동으로 찾는다.

@Autowired는 같은 타입의 빈이 두 개 이상 있는 경우에는 변수의 이름과 같은 이름의 빈을 가져온다.

```java
@Autowired
DataSource dataSource;
```

```java
@Autowired
SimpleDriverDataSource dataSource;
```

SimpleDriverDataSource DataSource 타입 중 어떤 걸 사용하는 게 좋을까?

개발자가 만든 테스트는 애플리케이션 클래스와 밀접한 관계를 맺고 있어도 상관없다. 내용을 증명해야하기 떄문 하지만, 꼭 필요하지 않다면 테스트에서도 인터페이스를 사용해 애플리케이션 코드와 느슨하게 연결하는 것이 좋다.

### 2.4.2 DI와 테스트

---

효율적인 테스트를 손쉽게 만들기 위해서 DI를 적용해야 한다.

작은 단위의 대상에서 테스트를 해야하는데, DI는 테스트가 작은 단위의 대상에 대해 독립적으로 만들어지고 실행되게 하는 역할

**테스트 코드에 의한 DI**

applicationContext.xml 설정을 테스트할 떄는 테스트용 DB를 사용하는 DataSource를 이용하도록 변경할 수도 있지만, 이는 번거롭다.

따라서 테스트 코드에 의한 DI를 사용해서 테스트 중에 DAO가 사용할 DataSource 오브젝트를 바꿔주면 된다.

![스크린샷 2022-11-28 오후 4.28.51.png](2%204%20%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%AD%E1%86%BC%208c39111c8e994d1eb04cf462d042c6a6/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-11-28_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.28.51.png)

@Before 메서드에서 테스트용 dataSource 오브젝트를 생성하고,

애플리케이션 컨텍스트에서 가져온 dao 오브젝트의 setDataSource()메서드를 통해 DI 할 수 있다.

이 방식의 장점은 xml 설정파일을 직접 수정하지 않고 테스트 코드를 통해 오브젝트 관계를 재구성했다는 것이다.

하지만, 이 방식은 애플리케이션 컨텍스트에서 [applicationContext.](http://applicationContext.ml)xml 오브젝트를 가져와 의존관계를 강제로 변경했다.

스프링 테스트 컨텍스트 프레임워크를 이용하면 애플리케이션 컨텍스트는 테스트 중에 딱 1개만 만들어지고 모든 테스트에서 공유해야한다.

따라서 애플리케이셔 컨텍스트의 구성이나 상태를 테스트 내에서 변경하면 안된다.

하지만 위의 테스트 코드는 애플리케이션 컨텍스트에서 가져온 UserDao 빈의 의존관계를 강제로 변경했고, 나머지 모든 테스트를 수행하는 동안 변경된 애플리케이션 컨텍스트가 사용된다.

따라서 `@DirtiesContext` 애노테이션을 추가하나다.

스프링 테스트 컨텍스트 프레임워크에서 해당 클래스의 테스트에서 애플리케이션 컨텍스트의 상태를 변경하니 애플리케이션 컨텍스트의 공유를 허용하지 않는다는 뜻이다.

따라서 해당 메서드를 수행하고 나면 새로운 애플리케이션 컨텍스트를 만들어서 다음 테스트에서 사용하게 해준다.

**테스트를 위한 별도의 DI 설정**

테스트에서 사용될 DataSource 클래스가 빈으로 정의된 테스트 전용 설정파일을 따로 만드는 방법

즉, 두 종류의 설정파일을 만들어서

하나는 서버에서 운영용으로 사용할 DataSource를 빈으로 등록하고,

다른 하나는 테스트에서 준비된 DB를 사용하는 가벼운 DataSource가 빈으로 등록되는 것이다.

테스트 전용 설정파일을 생성한 후에

UserDaoTest의 @ContextConfiguration 애노테이션에 있는 locations 앨리먼트의 값을 새로 만든 테스트용 설정파일로 변경해주면 된다.

![스크린샷 2022-11-28 오후 2.41.42.png](2%204%20%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%AD%E1%86%BC%208c39111c8e994d1eb04cf462d042c6a6/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-11-28_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.41.42.png)

테스트 환경에 적합한 구성을 가진 설정파일을 이용해서 테스트를 진행하면 된다.

또한 애플리케이션 컨텍스트도 한 개만 만들어서 모든 테스트에서 공유할 수 있다.

**컨테이너 없는 DI 테스트**

스프링 컨테이너를 이용해서 IoC방식으로 생성되고 DI가 되도록 하는 대신, 테스트 코드에서 직접 오브젝트를 만들고 DI를 해도 된다.

![스크린샷 2022-11-28 오후 2.44.00.png](2%204%20%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%AD%E1%86%BC%208c39111c8e994d1eb04cf462d042c6a6/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-11-28_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.44.00.png)

`@RunWith` 를 사용해서 스프링 테스트 프레임워크를 적용하지 않았고
`@Autowired` 를 사용해서 애플리케이션 컨텍스트에서 dao를 가져오지도 않았다.

대신 @Before 테스트 메서드에서 직접 UserDao, 테스트용 DataSource 오브젝트를 만들어 직접 DI 해주었다.

하지만, JUnit은 새로운 테스트 오브젝트를 만들기 떄문에 매번 새로운 UserDao 오브젝트가 만들어진다는 단점이 있다. 하지만 매우 가볍기 떄문에 걱정하지 않아도 된다.

DI는 객체지향 프로그래밍 스타일이다.

DI를 위해 컨테이너가 반드시 필요한 것은 아니다. 

**DI를 이용한 테스트 방법 선택**

1. 스프링 컨테이너 없이 테스트할 수 있는 방법

하지만, 여러 오브젝트와 복잡한 의존관계를 갖고 있는 오브젝트를 테스트해야할 경우

1. 테스트 전용 설정파일을 만들어 애플리케이션 컨텍스트 사용

예외적인 의존관계를 강제로 구성해서 테스트

1. 애플리케이션에서 DI 받은 오브젝트에 테스트 코드로 수동 DI해서 테스트

이때는 @DirtiesContext 를 추가해야함.(애플리케이션 컨텍스트는 공유되는 것인데 수정했기 때문)